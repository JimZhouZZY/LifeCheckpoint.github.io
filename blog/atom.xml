<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lifecheckpoint.github.io/blog</id>
    <title>Life_Checkpoint's Blog Blog</title>
    <updated>2024-12-19T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lifecheckpoint.github.io/blog"/>
    <subtitle>Life_Checkpoint's Blog Blog</subtitle>
    <icon>https://lifecheckpoint.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Welcome]]></title>
        <id>https://lifecheckpoint.github.io/blog/2024/12/19/welcome</id>
        <link href="https://lifecheckpoint.github.io/blog/2024/12/19/welcome"/>
        <updated>2024-12-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[欢迎逛逛...]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="欢迎逛逛">欢迎逛逛...<a href="https://lifecheckpoint.github.io/blog/2024/12/19/welcome#%E6%AC%A2%E8%BF%8E%E9%80%9B%E9%80%9B" class="hash-link" aria-label="Direct link to 欢迎逛逛..." title="Direct link to 欢迎逛逛...">​</a></h3>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="my-github">My Github...<a href="https://lifecheckpoint.github.io/blog/2024/12/19/welcome#my-github" class="hash-link" aria-label="Direct link to My Github..." title="Direct link to My Github...">​</a></h2>
<p><img decoding="async" loading="lazy" src="http://github-profile-summary-cards.vercel.app/api/cards/profile-details?username=lifecheckpoint&amp;theme=date_night" alt="Life_Checkpoint Details" class="img_ev3q">
<img decoding="async" loading="lazy" src="http://github-profile-summary-cards.vercel.app/api/cards/repos-per-language?username=lifecheckpoint&amp;theme=date_night" alt="Top Languages by Repo" class="img_ev3q">
<img decoding="async" loading="lazy" src="http://github-profile-summary-cards.vercel.app/api/cards/most-commit-language?username=lifecheckpoint&amp;theme=date_night" alt="Top Languages by Commits" class="img_ev3q">
<img decoding="async" loading="lazy" src="http://github-profile-summary-cards.vercel.app/api/cards/stats?username=lifecheckpoint&amp;theme=date_night" alt="Stats" class="img_ev3q">
<img decoding="async" loading="lazy" src="http://github-profile-summary-cards.vercel.app/api/cards/productive-time?username=lifecheckpoint&amp;theme=date_night&amp;utcOffset=8" alt="Commits (UTC+8)" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="deploy-this-project">Deploy This Project<a href="https://lifecheckpoint.github.io/blog/2024/12/19/welcome#deploy-this-project" class="hash-link" aria-label="Direct link to Deploy This Project" title="Direct link to Deploy This Project">​</a></h2>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">cmd /C 'set "GIT_USER=&lt;GITHUB_USER&gt;" &amp;&amp; set "CURRENT_BRANCH=main" &amp;&amp; yarn deploy'</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Life_Checkpoint</name>
            <uri>https://github.com/LifeCheckpoint</uri>
        </author>
        <category label="intro" term="intro"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[推箱子路径长估计问题随想]]></title>
        <id>https://lifecheckpoint.github.io/blog/2024/12/07/IDAStar-New-Algo-Thinking</id>
        <link href="https://lifecheckpoint.github.io/blog/2024/12/07/IDAStar-New-Algo-Thinking"/>
        <updated>2024-12-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[这个算法是我自己想出来的一个随机算法，能够平衡效率与时间]]></summary>
        <content type="html"><![CDATA[<p><em>这个算法是我自己想出来的一个随机算法，能够平衡效率与时间</em></p>
<p><strong>随机路径长估计</strong>适用于 IDA* 等算法的启发式函数</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="算法目的">算法目的<a href="https://lifecheckpoint.github.io/blog/2024/12/07/IDAStar-New-Algo-Thinking#%E7%AE%97%E6%B3%95%E7%9B%AE%E7%9A%84" class="hash-link" aria-label="Direct link to 算法目的" title="Direct link to 算法目的">​</a></h3>
<p>在搜索算法中，启发式函数常常被设定为 <code>Box</code> 到 <code>BoxTarget</code> 的曼哈顿距离，然而这种启发式函数并不算精准</p>
<p>传统的路径长估计也不可行。例如，在每一次计算 <code>loss</code> 时，都使用 <code>A*</code> 算法进行路径长估计，就会造成本末倒置：</p>
<ol>
<li>作为离散问题，最优解往往不一定让箱子直接推入目标点，这只是局部最优而非全局最优</li>
<li><code>A*</code> 把一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的算法变成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，造成算法的瓶颈，这是不可接受的</li>
</ol>
<p>因此，这里提出<strong>随机路径估计</strong>的算法进行路径的估计</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="算法内容">算法内容<a href="https://lifecheckpoint.github.io/blog/2024/12/07/IDAStar-New-Algo-Thinking#%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9" class="hash-link" aria-label="Direct link to 算法内容" title="Direct link to 算法内容">​</a></h3>
<p>算法需要一段时间的预处理，这个预处理需要用 <code>A*</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="预处理">预处理<a href="https://lifecheckpoint.github.io/blog/2024/12/07/IDAStar-New-Algo-Thinking#%E9%A2%84%E5%A4%84%E7%90%86" class="hash-link" aria-label="Direct link to 预处理" title="Direct link to 预处理">​</a></h4>
<ol>
<li>从地图中随机采样一对点，这一对点的曼哈顿距离不太近，也不太远</li>
<li>如果采样点有墙壁，弃去，重采</li>
<li>利用 <code>A*</code> 或 <code>BFS</code>（如果距离不算远）计算这一对点的真实距离</li>
<li>重复以上过程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span></span></span></span> 次</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="正式计算">正式计算<a href="https://lifecheckpoint.github.io/blog/2024/12/07/IDAStar-New-Algo-Thinking#%E6%AD%A3%EF%BF%BD%EF%BF%BD%E5%BC%8F%E8%AE%A1%E7%AE%97" class="hash-link" aria-label="Direct link to 正式计算" title="Direct link to 正式计算">​</a></h4>
<p>假定对于两个点 <code>A</code> <code>B</code>，使用以下算法估计 <code>A</code> 和 <code>B</code> 之间的距离：</p>
<ol>
<li>分别找到离 <code>A</code> <code>B</code> 两点最近的采样点 <code>A'</code> <code>B'</code></li>
<li>计算曼哈顿距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(A,A')+d(B,B')</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，然后加上预先计算好的采样点距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(A',B')</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>结果就是 <code>A</code> <code>B</code> 两点的近似距离</li>
<li>如果需要平滑，可以和 <code>A</code> <code>B</code> 两点之间的曼哈顿距离做加权平均</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="为什么能凑效">为什么能凑效？<a href="https://lifecheckpoint.github.io/blog/2024/12/07/IDAStar-New-Algo-Thinking#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%87%91%E6%95%88" class="hash-link" aria-label="Direct link to 为什么能凑效？" title="Direct link to 为什么能凑效？">​</a></h4>
<p>这个算法基于一个重要的假设：<strong>一对比较近的点，其曼哈顿距离对真实距离的近似程度，总是高于一对比较远的点，其曼哈顿距离对真实距离的近似程度</strong></p>]]></content>
        <author>
            <name>Life_Checkpoint</name>
            <uri>https://github.com/LifeCheckpoint</uri>
        </author>
        <category label="algo" term="algo"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[推箱子死锁检测问题随想]]></title>
        <id>https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-Corner-Deadlock-Test</id>
        <link href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-Corner-Deadlock-Test"/>
        <updated>2024-12-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[推箱子的死锁检测是一个复杂的问题，有专门的研究对该问题进行优化。]]></summary>
        <content type="html"><![CDATA[<p>推箱子的死锁检测是一个复杂的问题，有专门的研究对该问题进行优化。</p>
<p><a href="https://shenmian.github.io/sokoban-tutorial/solver/deadlocks.html" target="_blank" rel="noopener noreferrer">现代推箱子教程 - 死锁 DeadLock</a> 给出了死锁的一般定义</p>
<p><code>Tristan Cazenave</code> 与 <code>Nicolas Jouandeau</code> 的 <a href="https://www.lamsade.dauphine.fr/~cazenave/papers/sokoban.pdf" target="_blank" rel="noopener noreferrer">Towards deadlock free Sokoban</a> 给出了检测死锁的高效树算法（然而实现算法很困难）</p>
<p>死锁的类型非常多，增加了死锁的复杂性</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="死锁检测的目的">死锁检测的目的？<a href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-Corner-Deadlock-Test#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%9A%84%E7%9B%AE%E7%9A%84" class="hash-link" aria-label="Direct link to 死锁检测的目的？" title="Direct link to 死锁检测的目的？">​</a></h2>
<p>死锁检测可以用于<strong>早停</strong>，例如</p>
<ol>
<li>玩家的失败提示</li>
<li>Sokoban AI 搜索算法迭代的剪枝，减小搜索空间与分支常数</li>
</ol>
<p>但是死锁<strong>不一定代表失败</strong>，在某些创新玩法中，某些死锁反而可能是胜利的必要条件</p>
<hr>
<p>由于时间原因，这里仅采取一些常见情况的检测，能够做到初步的死锁检查</p>
<p><em>本质上是匹配人工建立的模式数据库</em></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="初步死锁检测">初步死锁检测<a href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-Corner-Deadlock-Test#%E5%88%9D%E6%AD%A5%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B" class="hash-link" aria-label="Direct link to 初步死锁检测" title="Direct link to 初步死锁检测">​</a></h2>
<p>初步的死锁有以下几种：</p>
<ol>
<li>角落死锁</li>
<li>胡同死锁</li>
<li>单侧死锁</li>
</ol>
<p>每种死锁都有不一样的适用条件</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="角落死锁">角落死锁<a href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-Corner-Deadlock-Test#%E8%A7%92%E8%90%BD%E6%AD%BB%E9%94%81" class="hash-link" aria-label="Direct link to 角落死锁" title="Direct link to 角落死锁">​</a></h3>
<p><strong>角落死锁</strong>指的是一个箱子被推到了两、三或四面垂直墙壁的夹角处，且所在位置没有目标点</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">######        ###    ###</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#   $#    #####$#    #$#</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#.   #    #     #    ###</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">######    #######</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这是一种绝对死锁，判断较为简单，直接判定箱子是否存在任意相邻两侧墙壁即可</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="胡同死锁">胡同死锁<a href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-Corner-Deadlock-Test#%E8%83%A1%E5%90%8C%E6%AD%BB%E9%94%81" class="hash-link" aria-label="Direct link to 胡同死锁" title="Direct link to 胡同死锁">​</a></h3>
<p><strong>胡同死锁</strong>指的是一个箱子被推到了死胡同中，胡同中没有目标点，并且绝对不存在走出胡同的方法</p>
<p>最简单的死胡同如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">   ###</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   # #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   # #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   # #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">####$####</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"># @    .#</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#########</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个死胡同的特点是：玩家与死胡同的另一部分<strong>不连通</strong>，从玩家连通块开始，箱子只有一个方向可以行进，且这个方向最后会进入角落死锁</p>
<p>注意，有一些胡同<strong>并不是</strong>死胡同，例如</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">######</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#    #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#    #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#    #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#### #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   # #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">####$####</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"># @   . #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#########</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>为什么不会产生死锁呢？因为在箱子移动到角落产生绝对死锁之前，玩家与胡同的另一部分发生了<strong>连通</strong>，由此破坏了胡同死锁的产生条件</p>
<p>因此在进行胡同死锁的检测的时候，应该遵循以下方法</p>
<ol>
<li>如果判定到箱子被两侧平行墙壁夹住</li>
<li>对箱子进行当前玩家连通方向的虚拟推动</li>
<li>检测是否产生...<!-- -->
<ol>
<li>角落死锁: 判定为绝对死锁</li>
<li>玩家块与胡同块发生连通: 不可判定为死锁</li>
<li>以上条件均不满足：继续进行虚拟推动</li>
</ol>
</li>
</ol>
<p><em>后面发现这个逻辑有一些 cases 无法通过，例如</em></p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">   #####</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">####   #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#  # # #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#    $ #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#.#### #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">######$##</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"># @   . #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#########</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>确实不是连通块，但胡同口的箱子也不是死锁状态</p>
<p>解决方法是，判断连通块时，将箱子视为空气，这样至多会漏判，但绝不会错判</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="单侧死锁">单侧死锁<a href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-Corner-Deadlock-Test#%E5%8D%95%E4%BE%A7%E6%AD%BB%E9%94%81" class="hash-link" aria-label="Direct link to 单侧死锁" title="Direct link to 单侧死锁">​</a></h3>
<p><strong>单侧死锁</strong>指的是一个箱子被推到了单侧墙壁，但是墙壁一侧没有任何目标点且箱子<strong>无法逃出</strong>单侧墙壁</p>
<p>例如</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#####</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#   #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#  $#</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#.  #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#####</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>同样需要指出的是，箱子移动到了单侧墙壁并不代表箱子发生了单侧死锁，因为箱子是有机会逃出单侧墙壁的</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">####</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#  #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"># $#</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#  #######</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#@      .#</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">##########</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>然而我们也不能简单的认为箱子能移动到空地就是死锁不成立，比如</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">####</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#  ###</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#    #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#  ###</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"># $#</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#  #######</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#@      .#</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">##########</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如果向上移动，虽然会出现四周无墙壁的情况，但如果内部是一个死胡同，情况就会转化为<strong>胡同死锁</strong></p>
<p>因此，可以用如下算法检测单侧死锁：</p>
<ol>
<li>如果箱子被移动到单侧墙壁</li>
<li>沿箱子两侧对箱子分别进行虚拟移动</li>
<li>如果箱子进入角落死锁，判定为单侧死锁</li>
<li>如果箱子进入四周空地的格子...<!-- -->
<ol>
<li>检查当前玩家块是否与能够将箱子垂直推离墙壁的块连通，如果连通，单侧死锁不成立</li>
<li>如果不连通...<!-- -->
<ol>
<li>将箱子沿墙壁方向继续移动，重复 2 3 4 步</li>
<li>将箱子向胡同内推入，检测胡同死锁</li>
<li>如果以上两个结果中有任意一个使死锁不成立，则认为单侧死锁不成立</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="其它说明">其它说明<a href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-Corner-Deadlock-Test#%E5%85%B6%E5%AE%83%E8%AF%B4%E6%98%8E" class="hash-link" aria-label="Direct link to 其它说明" title="Direct link to 其它说明">​</a></h2>
<p>以上死锁算法都通过递归或循环实现，需要指出的是，这些算法编写简单，但效率不高，所以出现了如下优化算法：</p>
<ol>
<li><strong>静态优化</strong>: 将进入某些特定死锁状态的箱子视为墙，懒惰更新一定会发生死锁的位置</li>
<li><strong>树优化</strong>：将箱子首次进入死锁的状态作为死锁树的根节点，通过拓展树节点高效获取死锁位置</li>
</ol>
<p>当然，也有暴力出奇迹的通用算法：</p>
<ol>
<li><strong>BFS &amp; DFS &amp; Beam Search 等传统搜索</strong></li>
<li><strong>A* IDA* 双向搜索 等启发式搜索</strong></li>
</ol>
<p>在不循环的前提下，暴力寻找所有可能的箱子移动空间，如果检测到箱子不可能移动到任何目标点，则认为死锁成立</p>
<p>缺点：</p>
<ol>
<li>传统搜索：<strong>巨慢</strong>，<del>地图很大，情况复杂，跑完一个算法的时间可能要用亿年来计</del></li>
<li>启发式搜索：相对快，但是对于大的地图依然需要一些时间，大地图的实时判断需掂量</li>
</ol>
<p>优化算法一般是是针对<strong>传统玩法</strong>开发的，如果需要通用性，可以做出针对性修改</p>
<p>如果感兴趣可以参阅更多资料</p>]]></content>
        <author>
            <name>Life_Checkpoint</name>
            <uri>https://github.com/LifeCheckpoint</uri>
        </author>
        <category label="algo" term="algo"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[推箱子割点检测问题随想]]></title>
        <id>https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-CutVertex-Test</id>
        <link href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-CutVertex-Test"/>
        <updated>2024-12-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[写一些便捷功能或搜索算法的时候，我们常常会遇到需要判断玩家是否能从箱子某一侧到达另一侧的问题]]></summary>
        <content type="html"><![CDATA[<p>写一些便捷功能或搜索算法的时候，我们常常会遇到需要判断<strong>玩家是否能从箱子某一侧到达另一侧</strong>的问题</p>
<p>传统的算法，判断玩家是否能从一个点移动到另一个点，需要纯 <code>BFS</code> 或 <code>DFS</code> 这样“大水漫灌”或“逐步搜索”的方法，寻找最终结果</p>
<p>然而这种算法的复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，面对较大的地图可能会花费较长的时间。具体解释如下：</p>
<blockquote>
<p>“在一个箱子推动路径搜索过程中，要反复判断人是否能从箱子的一侧自由移动（即不推动箱子情况下）到箱子的另一侧</p>
<p>“这个不难判断，用简单的广度和深度优先搜索都能在线性时间内得到答案</p>
<p>“但是箱子推动过程中，箱子位置在变化，要在不同的位置都作出判断</p>
<p>“假设涉及到的格子有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 个，每判断一次要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间，但箱子最多也可能出现在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 个不同的格子，要做 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 次这样的判断，所以总的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>“当关卡比较大时，如《一箭十万》是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mo>×</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">50\times50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">50</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">50</span></span></span></span> 的关卡，不算墙体，格子也上千，导致计算时间比较长</p>
</blockquote>
<p>那么，<strong>割点算法</strong>通过其 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mclose">)</span></span></span></span> 的优秀时间复杂度，成为我们进行判断的首选</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="割点算法引入">割点算法引入<a href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-CutVertex-Test#%E5%89%B2%E7%82%B9%E7%AE%97%E6%B3%95%E5%BC%95%E5%85%A5" class="hash-link" aria-label="Direct link to 割点算法引入" title="Direct link to 割点算法引入">​</a></h2>
<p>一个推箱子地图的割点，指的是<strong>能够把一个连通区域切割成两个或多个区域的位置</strong></p>
<p>例如</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#######</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"># #   #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"># #  ##</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#     #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#   # #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#######</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个地图的割点有</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#######</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"># # o #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#o#  ##</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#o ooo#</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#   # #</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#######</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如果知道了地图的割点，我们就可以优化玩家行动的计算：</p>
<ol>
<li>如果箱子不在割点上，说明玩家一定能从箱子一侧移动到另一侧</li>
<li>如果箱子在割点上，如果箱子两侧的块处在同一个连通区域，那么也能移动，反之不行</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考资料">参考资料<a href="https://lifecheckpoint.github.io/blog/2024/12/04/Sokoban-CutVertex-Test#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" class="hash-link" aria-label="Direct link to 参考资料" title="Direct link to 参考资料">​</a></h2>
<p><a href="http://sokoban.ws/blog/?p=843" target="_blank" rel="noopener noreferrer">推箱子游戏的一个箱子推动路径搜索算法 （二）</a></p>
<p><a href="http://sokoban.ws/blog/?p=1000" target="_blank" rel="noopener noreferrer">用深度优先搜索(DFS)确定图的割点</a></p>]]></content>
        <author>
            <name>Life_Checkpoint</name>
            <uri>https://github.com/LifeCheckpoint</uri>
        </author>
        <category label="algo" term="algo"/>
    </entry>
</feed>